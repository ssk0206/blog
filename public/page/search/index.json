[{"content":"第９章は『例外とアサーション』ですね。これは実務でもなんとなくで書いてしまっているので念入りにやりたいです。\nまずは、マルチキャッチについて。マルチキャッチを使うことで、コード量が劇的に減ります。\ntry { // do } catch (AException a | BException b) { // do } try { // do } catch (AException a) { } catch (BException b) { } 例外のマルチキャッチでは、同じ例外処理を一つのcatchブロックにまとめて記述することができます。同じ例外処理をしないのであれば、まとめるべきではないです。 ただし、一つのcatchブロックに記述できるのは、継承関係にない例外だけです。\nプログラマーが独自に作成する例外クラス Javaでは、プログラムが対処できるトラブルは「例外」、プログラムで対処できないトラブルは「エラー」とされている\n共通しているのが、スローできるという性質 この性質を表すのが、java.lang.Throwableクラス\nThrowable直下のサブクラスには、エラーを表すjava.lang.Errorと例外を表すjava.lang.Exceptionがあります。\nJavaの例外は、例外処理(try-catch文、throws宣言)の有無をコンパイラがチェックする検査例外と、チェックしない非検査例外に別れます。Exceptionクラスとそのサブクラスは基本的に検査例外ですが、java.lang.RuntimeExceptionクラスとそのサブクラスだけは非検査例外として扱われます。\n独自の例外クラスがExceptionクラスのサブクラスであることは必須条件ですが、RuntimeExceptionクラスのサブクラスである必要はラリません。\ntry-with-resources try-with-resourcesはJava SE 7で導入された機能で、プログラムの中で扱うリソースを自動的に閉じるためのものです。 一般的にプログラムで扱うリソースとは、プログラムからアクセスするデータを指しますが、Javaではデータだけでなく、アクセスするためのインスタンスなどもリソースとして扱います。\ntry-with-resource文の括弧で扱えるのは、java.lang.AutoCloseableインタフェース、もしくはCloseableインタフェースを実装したクラス\nAutoCloseableを実装したクラス\npublic class SampleResource implements AutoCloseable { @Override public void close() throws Exception { System.out.println(\u0026#34;close\u0026#34;); } } Closeableを実装したクラス\npublic class SampleResource implements Closeable { @Override public void close() throws IOException { System.out.println(\u0026#34;close\u0026#34;); } } try-with-resourcesの記述として、正しいもの\ntry (自動的に閉じるリソースの宣言) { リソースを使った処理 } 複数のリソースを対象とする場合は、\u0026quot;;\u0026ldquo;を区切って列挙します\ntryブロックの前でリソースを宣言\npublic class SampleUsing { public static void main(String[] args) throws Exception { SampleResource resource = new SampleResource(); try (resource) { // do } } } tryで宣言されたリソースが閉じる順番についての問題 宣言したときと逆の順序 で自動的に閉じていく\ntryブロック内で例外が発生しなければ、 リソースのクローズ -\u0026gt; finallyブロック リソースのクローズ -\u0026gt; catchブロック -\u0026gt; finallyブロック\n","date":"2023-03-07T00:00:00Z","permalink":"/post/java-gold-9/","title":"Java Gold 対策勉強"},{"content":"ロケール情報 Locale locale = Locale.getDefault(); Locale(String language) Locale(String language, String country) Locale(String language, String country, String variant) ","date":"2023-03-07T00:00:00Z","permalink":"/post/java-gold-10/","title":"Java Gold 対策勉強"},{"content":"アノテーションの定義 マーカーインターフェースとは、以下のコードのように何も持たず、クラスに意味を追加することだけを目的としたインタフェースのことです。\npublic interface Sample {} アノテーションは、プロセッサに何らかの処理をしてもらうため、クラスに意味を追加するという点ではマーカーインタフェースと同じですが、少し違います。\nプロセッサに値を渡すことができる。 フィールドやメソッド、コンストラクタなど細かな単位でマークすることができる。 アノテーションを独自に定義するには、次のように@interfaceというワードにつづけて定義します。\npublic @interface Sample {} アノテーションは、コンパイルされるとインタフェースに置き換わります。 Sampleアノテーションをコンパイルした結果のクラスファイルをjavapコマンドで整形したもの\nCompiled from \u0026#34;Sample.java\u0026#34; public interface Sample extends java.lang.annotation.Annotation {} アノテーションはjava.lang.annotation.Annotationインタフェースのサブインタフェースとして定義されます。 ただし、アノテーションはマーカーインターフェースとは異なり、implementsするわけではなく、アノテーションが付与されているという情報を残します。\n@Sample public class Test {} アノテーションはマーカーインタフェースと異なり、プロセッサに値を渡すことができる。アノテーションが付与されたクラスを定義するときに値を記述しておくことで、プロセッサはその値に応じた処理を実行することができます。\nアノテーションで値を扱いたい場合、その値を戻す抽象メソッドをアノテーションに追加します。定義するのはフィールドではない点に注意してください。\npublic @interface Test { String name(); int print(); } @Test(name = \u0026#34;test\u0026#34;, price = 100) public class Item { private String name; private int price; public Item(String name, int price) { this.name = name; this.price = price; } public String getName() { return name; } public int getPrice() { return price; } } アノテーションで扱う値のことを「注釈パラメータ」と呼びます。 注釈パラメータで値をプロセッサに渡したい場合は、「注釈パラメータ名＝値」の書式で記述します。\npublic @interface SampleValue { String value(); } 注釈パラメータ１つの場合、省略することも可能\n@SampleValue(value = \u0026#34;sample\u0026#34;) public class UseSample { } @SampleValue(\u0026#34;sample\u0026#34;) public class UseSample { } アノテーションの注釈パラメータに複数の値を設定することもできます。\n@ArrayValues(data = {1, 2, 3}) public class ArrayValueSample { } 注釈パラメータの定義でdefaultにつづけてデフォルト値\npublic @interface DefaultValue { String test() default \u0026#34;default\u0026#34;; } @DefaultValue public class DefaultValueSample { } リフレクション リフレクションを使えば、そのインスタンスが持っているメソッドやフィールドの種類を調べて、インスタンスを操作することができます。 インタフェースやクラス群はjava.lang.reflectパッケージに分類されています。\nリフレクションを理解する上でポイントとなるのが、java.lang.Classクラスです。\npublic class TestItem { public static void main(String[] args) { Class\u0026lt;Item\u0026gt; clazz = Item.class; Test test = clazz.getAnnotation(Test.class) } } メタ・アノテーションに関する問題です。 @Targetアノテーションは、アノテーションが何を対象としているのかを指定するためのメタ・アノテーションです。 @Targetアノテーションの注釈パラメータに渡す列挙型であるjava.lang.annotation.ElementTypeの列挙子には、次の表にあげる11種類があります。\n列挙子 対象 ANNOTATION_TYPE アノテーション宣言 \u0026hellip; \u0026hellip; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface NotNull { String message(); } public class Sample { @NotNull(message = \u0026#34;name is not allowed null\u0026#34;) private String name; public Sample(String name) { this.name = name; } public String getName() { return this.name; } } @Override スーパークラスのメソッドを再定義することを「オーバーライド」と呼びます。\npublic class A { public void hello() { System.out.println(\u0026#34;hello.\u0026#34;); } } public class B extends A { public void hello() { System.out.println(\u0026#34;hi.\u0026#34;); } } Aクラスのhelloメソッドを変更\npublic class A { public void hello(String name) { System.out.println(\u0026#34;hello.\u0026#34; + name); } } スーパークラスのメソッドの引数を変更すると、オーバーライドではなく、 オーバーロード(多重定義) しているとコンパイラに解釈されます。 設計者からすると、このような解釈は望んでいないこともあります。\nそこで、オーバーライドしたメソッドを変更し忘れたことをコンパイラが検知できる仕組みとして、 @Overrideアノテーション が提供されています。\npublic class B extents A { @Override public void hello() { System.out.println(\u0026#34;hi.\u0026#34;); } } サブクラスでオーバーライドしたメソッドに@Overrideアノテーションをつけることにより、 スーパークラスのオーバーライドされた側のメソッドとシグニチャが一致するかどうかをコンパイラがチェックし、 一致しなければコンパイルエラーを出力します。\n以上のことから、スーパークラスの変更を検知するために使えるアノテーションは、@Overrideアノテーション @Deprecatedは、バージョン変更などによって使用できなくなる可能性があるものに付与するためのアノテーションです。@SuppressWarningsは、コンパイラが発する警告を抑制するためのアノテーションです。\n@Deprecatedアノテーションに関する問題 長いソフトウェアのライフサイクルの中で、モジュール、インタフェース、クラスが提供する機能は変わっていきます。そのとき、下位互換性をどれくらい担保するかが課題になってきます。 下位互換性とは、ソフトウェアが変更され、新しいバージョンになっても、変更される前に使えた機能がそのまま使えるという性質を指します。\nそこで、変更直後は変更前の機能をそのまま使えるようにしておき、変更後の機能へ移行する一定の期間を設ける方法が採られます。非推奨であることを明示するには、仕様書などのドキュメントやJavadocに記載する方法などがありますが、Java SE 5.0から@Deprecatedアノテーションが使えるようになりました。\n@SuppressWarningsアノテーションで警告を抑制\nimport java.util.ArrayList; import java.util.List; // コンパイラの警告を抑制することを明示 @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public class Sample { public void sample() { List list = new ArrayList(); list.add(\u0026#34;String\u0026#34;); } } @SuppressWarningsアノテーションには、注釈パラメータとして抑制したい対象を表す文字列を渡します。 Java言語仕様で規定されている文字列は、「unchecked」「deprecation」「removal」の3つ。\n","date":"2022-03-06T00:00:00Z","permalink":"/post/hello-world/","title":"Java Gold 対策勉強"}]